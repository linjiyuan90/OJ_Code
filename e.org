
;; #+LATEX_HEADER: \input{lib.tex}

* Basic Key

| key     | meaning                |
| C-x C-f | open file              |
| C-x C-w | save to different name |
| C-x b   | open last buffer       |
| C-x C-b | list buffer            |
| C-x C-s | save                   |
| C-x C-c | quit                   |


| key       | meaning        |
| M-!       | exec shell cmd |
| M-x dired | invoke *Dired* |


| key     | meaning           |
| C-g     | quit previous cmd |
|         |                   |

** Repeat
C-u k repeat times, without k, default is 4
M-[digit]
| C-u 3 C-p   | back 3 lines     |
| M-1 M-0 C-f | forward 10 char  |
| C-u C-n     | forward 4 lines  |
| C-u C-u C-n | forward 16 lines |

| M-g g | jump to g line |

| C-s | incremental search forward  |
| C-r | incremental search backward |

** Undo
| C-_   |
| C-/   |
| C-x u |


** Mark
| C-SPC     | set mark                 |
| C-x C-x   | swap point and mark      |
| C-u C-SPC | Cycle through mark ring  |

** Region
| C-x h   | select all                            |
| M-h     | select current paragraph              |
| C-x n n | narrow/hide buffer the current region | *narrowing*
| C-x n w | restore("widen") buffer               |


** Moving around
| C-f | forward one char    |
| C-b | backward one char   |
| M-f | forward one word    |
| M-b | backward one word   |
| C-n | next line           |
| C-p | previous line       |
| C-a | beginning of line   |
| C-e | end of line         |
| M-a | previous sentence   |
| M-e | next sentence       |
| M-v | previous screen     |
| C-v | next screen         |
| M-< | beginning of buffer |
| M-> | end of buffer       |


| M-0 C-k               | kill till beginning of line           |
| C-k                   | kill till end of line                 |
| C-S-backspace         | (S:shift) kill line                   |
| M-x kill-whole-line   |                                       |
| C-w                   | cut                                   |
| M-w                   | copy                                  |
| C-d                   | kill next char                        |
| M-d                   | kill next word                        |
| M-k                   | kill to end of sentence               |
| C-y                   | yanks last killed text                |
| M-y                   | cycle through previously killed items |
| C-S-backspace C-y C-y | copy a line :-)                       |


** Search & Replacement
| C-s     | Incremental forward search             |
| C-r     | Incremental backward search            |
| C-s C-s | search for most recently searched item |
| C-s C-s | search for most recently searched item |
| C-s M-p | Previous item in search history        |
| C-s M-n | Next item in search history            |
C-s/r to jump to the next/previous occurrence
C-g cancel
| M-% | query replace |
y to replace the current match
n to skip
q exit
. replace this and exit
! replace all remaining matches
how to replace all?

| C-M-s | regular expression incremental search |
M-x replace-regexp

For example

** Keyboard Macros
| F3     | start recording                                     |
| F4     | stop recording                                      |
| F4     | play back                                           |
| M-5 F4 | play back 5 times                                   |
| M-0 F4 | play back over and over until it fails, be careful! |
   newline: C-e C-j bind it

   
*

* Dired mode
  | d | mark delete |
  | x | execute     |
  | + | create      |



** Renaming files is as easy as *editing text*. 
   First, C-x C-q(or M-x wdired-change-to-wdired-mode) switch to *Editable Dired mode*
   edit the file name and C-x C-s
Batch renaming: search and replace

* links
[[~/helloworld.txt][hello]]

* other
| C-x z | repeat last cmd |
|       |                 |



#+begin_src  C++
int main() {
  return 0;
}
#+end_src

#+results:
: 2

#+begin_src erlang
  %% A process whose only job is to keep a counter.

  -module(counter).
  -export([start/0, codeswitch/1]).

  start() -> loop(0).

  loop(Sum) ->
    receive
       {increment, Count} ->
          loop(Sum+Count);
       reset ->
          loop(0);
       {counter, Pid} ->
          Pid ! {counter, Sum},
          loop(Sum);
       code_switch ->
          ?MODULE:codeswitch(Sum)
    end.

  codeswitch(Sum) -> loop(Sum).
#+end_src

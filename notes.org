
* Notes
** leetcode
*** Next Permutation
    One way to have a larger permutation in a[i-1, n) is to find the
    minimum a[j] where a[j] > a[i-1], j \in [i, n), then swap(a[i-1],
    a[j]) and sort a[i, n).

    To guarantee we find the next permutation, we have to scan from
    right to left, find the first i that has a larger permutation in
    a[i-1, n). Then swap and sort like above. Since i is the first one has a
    larger permutation, we know that a[i, n) is nonincreasing, just
    reverse a[i, n) will sort them.

    O(n)
*** Median of Two Sorted Arrays 
    sa + sb = s will guarantee correct drop operation.

    But notice when s = 1, need to set sa = sb = 1.
*** Trapping Rain Water
    maintain a monotonous stack
    Each time, calculate the increment.
*** random list
*** gas station
    greedy approach
*** Copy list with random pointer
    the cool idea is to duplicate the node
    then seperate it
    1->2->3
    1->1'->2->2'->3->3'
*** single number II
    count every digit, and module it with 3.
*** Convert Sorted List to Binary Search Tree
    move the current head while building
*** recursive level order traversal
    https://github.com/Dionysus1227/edocteel/blob/master/Binary%20Tree%20Level%20Order%20Traversal.cc
*** Recover Binary Search Tree
    dfs, use =TreeNode *&prev= to record prev pointer
*** reverse linked list 2
    change cur->next instead of cur
    
*** Largest Rectangle in Histogram
    : left[i] = left[left[i]];
*** Search in Rotated Sorted Array 2
    If duplicates are allowed, the search_gap program may fail due to the head
    may equal to tail of the array. *Just remove the tail which equal to head*
    More elegant algorithm is without search_gap first.
    https://github.com/Dionysus1227/edocteel/blob/master/Search%20in%20Rotated%20Sorted%20Array%20II.cc
*** Divide two integers
    Like Fast Exponentiation. Recursively solve it.
    #+BEGIN_SRC C++
    int dfs(a, b) {
      if ...
      // try 2*b
      ans = dfs(a, b+b)
      ans += ans  // need to double
      if (a >= b) {
        a -= b;
        ++ ans;
      }
      return ans;
    }
    #+END_SRC
    
* sth
** Using iterator may be more beautiful than index
** after finishing the code, remember to test with simple case!
   For tree, test NULL, 1 node, 2 nodes
